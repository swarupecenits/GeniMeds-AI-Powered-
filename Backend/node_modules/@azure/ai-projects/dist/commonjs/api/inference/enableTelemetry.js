"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.enableTelemetry = enableTelemetry;
const tslib_1 = require("tslib");
const opentelemetry = tslib_1.__importStar(require("@opentelemetry/api"));
const instrumentation_1 = require("@opentelemetry/instrumentation");
const opentelemetry_instrumentation_azure_sdk_1 = require("@azure/opentelemetry-instrumentation-azure-sdk");
const instrumentation_openai_1 = require("@traceloop/instrumentation-openai");
const instrumentation_langchain_1 = require("@traceloop/instrumentation-langchain");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const exporter_trace_otlp_grpc_1 = require("@opentelemetry/exporter-trace-otlp-grpc");
const api_logs_1 = require("@opentelemetry/api-logs");
const sdk_logs_1 = require("@opentelemetry/sdk-logs");
const exporter_logs_otlp_grpc_1 = require("@opentelemetry/exporter-logs-otlp-grpc");
const logger_js_1 = require("../../logger.js");
/**
 * Enables telemetry collection with OpenTelemetry for Azure AI clients and popular GenAI libraries.
 *
 * Following instrumentations are enabled (when corresponding packages are installed):
 * - Azure AI Agents (`@azure/ai-agents`)
 * - Azure AI Inference (`@azure-rest/ai-inference`)
 * - OpenAI (`@traceloop/instrumentation-openai`)
 * - Langchain (`@traceloop/instrumentation-langchain`)
 *
 * When destination is provided, the method configures OpenTelemetry SDK to export traces to
 * stdout or OTLP (OpenTelemetry protocol) gRPC endpoint. It's recommended for local
 * development only. For production use, make sure to configure OpenTelemetry SDK directly.
 *
 * @param destination - Recommended for local testing only. Set it to `"stdout"` for
 *        tracing to console output, or a string holding the OpenTelemetry protocol (OTLP)
 *        endpoint such as "http://localhost:4317".
 *        If not provided, the method enables instrumentations, but does not configure OpenTelemetry
 *        SDK to export traces.
 */
function enableTelemetry(destination) {
    const spanExporter = getTraceExporter(destination);
    configureTracing(spanExporter);
    const logExporter = getLogExporter(destination);
    configureLogging(logExporter);
    // Try to configure Azure SDK tracing and instrument AI Inference
    try {
        (0, instrumentation_1.registerInstrumentations)({
            instrumentations: [(0, opentelemetry_instrumentation_azure_sdk_1.createAzureSdkInstrumentation)()],
        });
    }
    catch (error) {
        logger_js_1.logger.warning("Could not register `createAzureSdkInstrumentation()`");
    }
    // TODO: Try to instrument AI Agents
    // Try to instrument OpenAI
    try {
        (0, instrumentation_1.registerInstrumentations)({
            instrumentations: [new instrumentation_openai_1.OpenAIInstrumentation()],
        });
    }
    catch (error) {
        logger_js_1.logger.warning("Could not register `new OpenAIInstrumentation()`");
    }
    // Try to instrument Langchain
    try {
        (0, instrumentation_1.registerInstrumentations)({
            instrumentations: [new instrumentation_langchain_1.LangChainInstrumentation()],
        });
    }
    catch (error) {
        logger_js_1.logger.warning("Could not call LangchainInstrumentor().instrument()` since " +
            "`@traceloop/instrumentation-langchain` is not installed");
    }
}
/**
 * Gets the appropriate trace exporter based on the destination
 * @param destination - The destination for exporting traces
 * @returns The trace exporter instance or undefined
 */
function getTraceExporter(destination) {
    if (!destination) {
        return undefined;
    }
    try {
        if (destination === "stdout") {
            return new sdk_trace_node_1.ConsoleSpanExporter();
        }
        else if (typeof destination === "string") {
            return new exporter_trace_otlp_grpc_1.OTLPTraceExporter({ url: destination });
        }
    }
    catch (error) {
        logger_js_1.logger.error("Failed to create trace exporter", error);
        return undefined;
    }
    return undefined;
}
/**
 * Gets the appropriate log exporter based on the destination
 * @param destination - The destination for exporting logs
 * @returns The log exporter instance or undefined
 */
function getLogExporter(destination) {
    if (!destination) {
        return undefined;
    }
    try {
        if (destination === "stdout") {
            return new sdk_logs_1.ConsoleLogRecordExporter();
        }
        else if (typeof destination === "string") {
            return new exporter_logs_otlp_grpc_1.OTLPLogExporter({ url: destination });
        }
    }
    catch (error) {
        logger_js_1.logger.warning("Failed to configure OpenTelemetry logging exporter.");
        return undefined;
    }
    return undefined;
}
/**
 * Configures OpenTelemetry tracing
 * @param spanExporter - The span exporter to use
 */
function configureTracing(spanExporter) {
    if (!spanExporter) {
        return;
    }
    try {
        let provider;
        // Check if tracing was not set up before
        try {
            const existingProvider = opentelemetry.trace.getTracerProvider();
            // Check if the provider is already a NodeTracerProvider by checking for addSpanProcessor method
            if (!("register" in existingProvider) ||
                typeof existingProvider.register !== "function" ||
                existingProvider.register.name !== "register") {
                // If the provider is not a NodeTracerProvider, we need to set up a new provider
                provider = new sdk_trace_node_1.NodeTracerProvider({
                    spanProcessors: [new sdk_trace_node_1.SimpleSpanProcessor(spanExporter)],
                });
                provider.register();
            }
            else {
                // If the provider is already a NodeTracerProvider, we can use it
                provider = existingProvider;
            }
        }
        catch (error) {
            // If we get here, we need to set up a new provider
            provider = new sdk_trace_node_1.NodeTracerProvider({
                spanProcessors: [new sdk_trace_node_1.SimpleSpanProcessor(spanExporter)],
            });
            provider.register();
        }
    }
    catch (error) {
        throw error;
    }
}
/**
 * Configures OpenTelemetry logging
 * @param logExporter - The log exporter to use
 */
function configureLogging(logExporter) {
    if (!logExporter) {
        return;
    }
    try {
        let loggerProvider;
        try {
            const existingProvider = api_logs_1.logs.getLoggerProvider();
            if (!(existingProvider instanceof sdk_logs_1.LoggerProvider)) {
                loggerProvider = new sdk_logs_1.LoggerProvider();
                api_logs_1.logs.setGlobalLoggerProvider(loggerProvider);
            }
            else {
                loggerProvider = existingProvider;
            }
        }
        catch (error) {
            // If we get here, we need to set up a new provider
            loggerProvider = new sdk_logs_1.LoggerProvider();
            api_logs_1.logs.setGlobalLoggerProvider(loggerProvider);
        }
        loggerProvider.addLogRecordProcessor(new sdk_logs_1.SimpleLogRecordProcessor(logExporter));
    }
    catch (error) {
        logger_js_1.logger.warning("Failed to configure OpenTelemetry logging. This might be because OpenTelemetry logs API is still experimental.");
    }
}
//# sourceMappingURL=enableTelemetry.js.map