/** Response from the list and get connections operations */
export interface Connection {
    /** The friendly name of the connection, provided by the user. */
    readonly name: string;
    /** A unique identifier for the connection, generated by the service */
    readonly id: string;
    /** Category of the connection */
    readonly type: ConnectionType;
    /** The connection URL to be used for this service */
    readonly target: string;
    /** Whether the connection is tagged as the default connection of its type */
    readonly isDefault: boolean;
    /** The credentials used by the connection */
    readonly credentials: BaseCredentialsUnion;
    /** Metadata of the connection */
    readonly metadata: Record<string, string>;
}
/** The Type (or category) of the connection */
export type ConnectionType = "AzureOpenAI" | "AzureBlob" | "AzureStorageAccount" | "CognitiveSearch" | "CosmosDB" | "ApiKey" | "AppConfig" | "AppInsights" | "CustomKeys";
/** A base class for connection credentials */
export interface BaseCredentials {
    /** The type of credential used by the connection */
    /** The discriminator possible values: ApiKey, AAD, CustomKeys, SAS, None */
    readonly type: CredentialType;
}
export declare function connectionDeserializer(item: any): Connection;
export declare function baseCredentialsDeserializer(item: any): BaseCredentials;
/** Alias for BaseCredentialsUnion */
export type BaseCredentialsUnion = ApiKeyCredentials | EntraIDCredentials | CustomCredential | SASCredentials | NoAuthenticationCredentials | BaseCredentials;
export declare function baseCredentialsUnionDeserializer(item: any): BaseCredentialsUnion;
/** The credential type used by the connection */
export type CredentialType = "ApiKey" | "AAD" | "SAS" | "CustomKeys" | "None";
/** API Key Credential definition */
export interface ApiKeyCredentials extends BaseCredentials {
    /** The credentail type */
    readonly type: "ApiKey";
    /** API Key */
    readonly apiKey?: string;
}
export declare function apiKeyCredentialsDeserializer(item: any): ApiKeyCredentials;
/** Entra ID credential definition */
export interface EntraIDCredentials extends BaseCredentials {
    /** The credential type */
    readonly type: "AAD";
}
export declare function entraIDCredentialsDeserializer(item: any): EntraIDCredentials;
/** Custom credential definition */
export interface CustomCredential extends BaseCredentials {
    /** The credential type */
    readonly type: "CustomKeys";
    /** The credential type */
    readonly keys: Record<string, string>;
}
export declare function customCredentialDeserializer(item: any): CustomCredential;
/** Shared Access Signature (SAS) credential definition */
export interface SASCredentials extends BaseCredentials {
    /** The credential type */
    readonly type: "SAS";
    /** SAS token */
    readonly sasToken?: string;
}
export declare function sasCredentialsDeserializer(item: any): SASCredentials;
/** Credentials that do not require authentication */
export interface NoAuthenticationCredentials extends BaseCredentials {
    /** The credential type */
    readonly type: "None";
}
export declare function noAuthenticationCredentialsDeserializer(item: any): NoAuthenticationCredentials;
/** Paged collection of Connection items */
export interface _PagedConnection {
    /** The Connection items on this page */
    value: Connection[];
    /** The link to the next page of items */
    nextLink?: string;
}
export declare function _pagedConnectionDeserializer(item: any): _PagedConnection;
export declare function connectionArrayDeserializer(result: Array<Connection>): any[];
/** Evaluation Definition */
export interface Evaluation {
    /** Identifier of the evaluation. */
    readonly name: string;
    /** Data for evaluation. */
    data: InputDataUnion;
    /** Display Name for evaluation. It helps to find the evaluation easily in AI Foundry. It does not need to be unique. */
    displayName?: string;
    /** Description of the evaluation. It can be used to store additional information about the evaluation and is mutable. */
    description?: string;
    /** Status of the evaluation. It is set by service and is read-only. */
    readonly status?: string;
    /** Evaluation's tags. Unlike properties, tags are fully mutable. */
    tags?: Record<string, string>;
    /** Evaluation's properties. Unlike tags, properties are add-only. Once added, a property cannot be removed. */
    properties?: Record<string, string>;
    /** Evaluators to be used for the evaluation. */
    evaluators: Record<string, EvaluatorConfiguration>;
}
/** optional id property for Evaluation, which shouldbe used for create operation */
export type EvaluationWithOptionalName = Omit<Evaluation, "name"> & {
    name?: string;
};
export declare function evaluationSerializer(item: EvaluationWithOptionalName): any;
export declare function evaluationDeserializer(item: any): Evaluation;
/** Abstract data class. */
export interface InputData {
    /** Type of the data */
    /** The discriminator possible values: dataset */
    type: string;
}
export declare function inputDataSerializer(item: InputData): any;
export declare function inputDataDeserializer(item: any): InputData;
/** Alias for InputDataUnion */
export type InputDataUnion = InputDataset | InputData;
export declare function inputDataUnionSerializer(item: InputDataUnion): any;
export declare function inputDataUnionDeserializer(_item: any): InputDataUnion;
/** Dataset as source for evaluation. */
export interface InputDataset extends InputData {
    /** Type of the data */
    type: "dataset";
    /** Evaluation input data */
    id: string;
}
export declare function inputDatasetSerializer(item: InputDataset): any;
export declare function inputDatasetDeserializer(item: any): InputDataset;
export declare function evaluatorConfigurationRecordSerializer(item: Record<string, EvaluatorConfiguration>): Record<string, any>;
export declare function evaluatorConfigurationRecordDeserializer(item: Record<string, any>): Record<string, EvaluatorConfiguration>;
/** Evaluator Configuration */
export interface EvaluatorConfiguration {
    /** Identifier of the evaluator. */
    id: string;
    /** Initialization parameters of the evaluator. */
    initParams?: Record<string, any>;
    /** Data parameters of the evaluator. */
    dataMapping?: Record<string, string>;
}
export declare function evaluatorConfigurationSerializer(item: EvaluatorConfiguration): any;
export declare function evaluatorConfigurationDeserializer(item: any): EvaluatorConfiguration;
/** Paged collection of Evaluation items */
export interface _PagedEvaluation {
    /** The Evaluation items on this page */
    value: Evaluation[];
    /** The link to the next page of items */
    nextLink?: string;
}
export declare function _pagedEvaluationDeserializer(item: any): _PagedEvaluation;
export declare function evaluationArraySerializer(result: Array<Evaluation>): any[];
export declare function evaluationArrayDeserializer(result: Array<Evaluation>): any[];
/** Evaluation request for agent run. */
export interface AgentEvaluationRequest {
    /** Identifier of the agent run. */
    runId: string;
    /** Identifier of the agent thread. This field is mandatory currently, but it will be optional in the future. */
    threadId?: string;
    /** Evaluators to be used for the evaluation. */
    evaluators: Record<string, EvaluatorConfiguration>;
    /** Sampling configuration for the evaluation. */
    samplingConfiguration?: AgentEvaluationSamplingConfiguration;
    /** Redaction configuration for the evaluation. */
    redactionConfiguration?: AgentEvaluationRedactionConfiguration;
    /** Pass the AppInsights connection string to the agent evaluation for the evaluation results and the errors logs. */
    appInsightsConnectionString: string;
}
export declare function agentEvaluationRequestSerializer(item: AgentEvaluationRequest): any;
/** Definition for sampling strategy. */
export interface AgentEvaluationSamplingConfiguration {
    /** Name of the sampling strategy. */
    name: string;
    /** Percentage of sampling per hour (0-100). */
    samplingPercent: number;
    /** Maximum request rate per hour (0 to 1000). */
    maxRequestRate: number;
}
export declare function agentEvaluationSamplingConfigurationSerializer(item: AgentEvaluationSamplingConfiguration): any;
/** The redaction configuration will allow the user to control what is redacted. */
export interface AgentEvaluationRedactionConfiguration {
    /** Redact score properties. If not specified, the default is to redact in production. */
    redactScoreProperties?: boolean;
}
export declare function agentEvaluationRedactionConfigurationSerializer(item: AgentEvaluationRedactionConfiguration): any;
/** Evaluation response for agent evaluation run. */
export interface AgentEvaluation {
    /** Identifier of the agent evaluation run. */
    id: string;
    /** Status of the agent evaluation. Options: Running, Completed, Failed. */
    status: string;
    /** The reason of the request failure for the long running process, if applicable. */
    error?: string;
    /** The agent evaluation result. */
    result?: AgentEvaluationResult[];
}
export declare function agentEvaluationDeserializer(item: any): AgentEvaluation;
export declare function agentEvaluationResultArrayDeserializer(result: Array<AgentEvaluationResult>): any[];
/** Result for the agent evaluation evaluator run. */
export interface AgentEvaluationResult {
    /** Evaluator's name. This is the name of the evaluator that was used to evaluate the agent's completion. */
    evaluator: string;
    /** Identifier of the evaluator. */
    evaluatorId: string;
    /** Score of the given evaluator. No restriction on range. */
    score: number;
    /** Status of the evaluator result. Options: Running, Completed, Failed, NotApplicable. */
    status: string;
    /** Reasoning for the evaluation result. */
    reason?: string;
    /** Version of the evaluator that was used to evaluate the agent's completion. */
    version?: string;
    /** The unique identifier of the thread. */
    threadId?: string;
    /** The unique identifier of the run. */
    runId: string;
    /** A string explaining why there was an error, if applicable. */
    error?: string;
    /** Additional properties relevant to the evaluator. These will differ between evaluators. */
    additionalDetails?: Record<string, string>;
}
export declare function agentEvaluationResultDeserializer(item: any): AgentEvaluationResult;
/** Paged collection of DatasetVersion items */
export interface _PagedDatasetVersion {
    /** The DatasetVersion items on this page */
    value: DatasetVersionUnion[];
    /** The link to the next page of items */
    nextLink?: string;
}
export declare function _pagedDatasetVersionDeserializer(item: any): _PagedDatasetVersion;
export declare function datasetVersionUnionArraySerializer(result: Array<DatasetVersionUnion>): any[];
export declare function datasetVersionUnionArrayDeserializer(result: Array<DatasetVersionUnion>): any[];
/** DatasetVersion Definition */
export interface DatasetVersion {
    /** URI of the data. Example: https://go.microsoft.com/fwlink/?linkid=2202330 */
    dataUri: string;
    /** Dataset type */
    /** The discriminator possible values: uri_file, uri_folder */
    type: DatasetType;
    /** Indicates if the dataset holds a reference to the storage, or the dataset manages storage itself. If true, the underlying data will not be deleted when the dataset version is deleted */
    readonly isReference?: boolean;
    /** The Azure Storage Account connection name. Required if startPendingUploadVersion was not called before creating the Dataset */
    connectionName?: string;
    /** Asset ID, a unique identifier for the asset */
    readonly id?: string;
    /** The name of the resource */
    readonly name: string;
    /** The version of the resource */
    readonly version: string;
    /** The asset description text. */
    description?: string;
    /** Tag dictionary. Tags can be added, removed, and updated. */
    tags?: Record<string, string>;
}
export declare function datasetVersionSerializer(item: DatasetVersion): any;
export declare function datasetVersionDeserializer(item: any): DatasetVersion;
/** Alias for DatasetVersionUnion */
export type DatasetVersionUnion = FileDatasetVersion | FolderDatasetVersion | DatasetVersion;
export declare function datasetVersionUnionSerializer(item: DatasetVersionUnion): any;
export declare function datasetVersionUnionDeserializer(item: any): DatasetVersionUnion;
/** Enum to determine the type of data. */
export type DatasetType = "uri_file" | "uri_folder";
/** FileDatasetVersion Definition */
export interface FileDatasetVersion extends DatasetVersion {
    /** Dataset type */
    type: "uri_file";
}
export declare function fileDatasetVersionSerializer(item: FileDatasetVersion): any;
export declare function fileDatasetVersionDeserializer(item: any): FileDatasetVersion;
/** FileDatasetVersion Definition */
export interface FolderDatasetVersion extends DatasetVersion {
    /** Dataset type */
    type: "uri_folder";
}
export declare function folderDatasetVersionSerializer(item: FolderDatasetVersion): any;
export declare function folderDatasetVersionDeserializer(item: any): FolderDatasetVersion;
/** Represents a request for a pending upload. */
export interface PendingUploadRequest {
    /** If PendingUploadId is not provided, a random GUID will be used. */
    pendingUploadId?: string;
    /** Azure Storage Account connection name to use for generating temporary SAS token */
    connectionName?: string;
    /** BlobReference is the only supported type. */
    pendingUploadType: "BlobReference";
}
export declare function pendingUploadRequestSerializer(item: PendingUploadRequest): any;
/** Represents the response for a pending upload request */
export interface PendingUploadResponse {
    /** Container-level read, write, list SAS. */
    blobReference: BlobReference;
    /** ID for this upload request. */
    pendingUploadId: string;
    /** Version of asset to be created if user did not specify version when initially creating upload */
    version?: string;
    /** BlobReference is the only supported type */
    pendingUploadType: "BlobReference";
}
export declare function pendingUploadResponseDeserializer(item: any): PendingUploadResponse;
/** Blob reference details. */
export interface BlobReference {
    /** Blob URI path for client to upload data. Example: https://blob.windows.core.net/Container/Path */
    blobUri: string;
    /** ARM ID of the storage account to use. */
    storageAccountArmId: string;
    /** Credential info to access the storage account. */
    credential: SasCredential;
}
export declare function blobReferenceDeserializer(item: any): BlobReference;
/** SAS Credential definition */
export interface SasCredential {
    /** SAS uri */
    readonly sasUri: string;
    /** Type of credential */
    readonly type: "SAS";
}
export declare function sasCredentialDeserializer(item: any): SasCredential;
/** Represents a reference to a blob for consumption */
export interface AssetCredentialResponse {
    /** Credential info to access the storage account. */
    blobReference: BlobReference;
}
export declare function assetCredentialResponseDeserializer(item: any): AssetCredentialResponse;
/** Paged collection of Index items */
export interface _PagedIndex {
    /** The Index items on this page */
    value: IndexUnion[];
    /** The link to the next page of items */
    nextLink?: string;
}
export declare function _pagedIndexDeserializer(item: any): _PagedIndex;
export declare function indexUnionArraySerializer(result: Array<IndexUnion>): any[];
export declare function indexUnionArrayDeserializer(result: Array<IndexUnion>): any[];
/** Index resource Definition */
export interface Index {
    /** Type of index */
    /** The discriminator possible values: AzureSearch, ManagedAzureSearch, CosmosDBNoSqlVectorStore */
    type: IndexType;
    /** Asset ID, a unique identifier for the asset */
    readonly id?: string;
    /** The name of the resource */
    readonly name: string;
    /** The version of the resource */
    readonly version: string;
    /** The asset description text. */
    description?: string;
    /** Tag dictionary. Tags can be added, removed, and updated. */
    tags?: Record<string, string>;
}
export declare function indexSerializer(item: Index): any;
export declare function indexDeserializer(item: any): Index;
/** Alias for IndexUnion */
export type IndexUnion = AzureAISearchIndex | ManagedAzureAISearchIndex | CosmosDBIndex | Index;
export declare function indexUnionSerializer(item: IndexUnion): any;
export declare function indexUnionDeserializer(item: any): IndexUnion;
/** Type of IndexType */
export type IndexType = "AzureSearch" | "CosmosDBNoSqlVectorStore" | "ManagedAzureSearch";
/** Azure AI Search Index Definition */
export interface AzureAISearchIndex extends Index {
    /** Type of index */
    type: "AzureSearch";
    /** Name of connection to Azure AI Search */
    connectionName: string;
    /** Name of index in Azure AI Search resource to attach */
    indexName: string;
    /** Field mapping configuration */
    fieldMapping?: FieldMapping;
}
export declare function azureAISearchIndexSerializer(item: AzureAISearchIndex): any;
export declare function azureAISearchIndexDeserializer(item: any): AzureAISearchIndex;
/** Field mapping configuration class */
export interface FieldMapping {
    /** List of fields with text content */
    contentFields: string[];
    /** Path of file to be used as a source of text content */
    filepathField?: string;
    /** Field containing the title of the document */
    titleField?: string;
    /** Field containing the url of the document */
    urlField?: string;
    /** List of fields with vector content */
    vectorFields?: string[];
    /** List of fields with metadata content */
    metadataFields?: string[];
}
export declare function fieldMappingSerializer(item: FieldMapping): any;
export declare function fieldMappingDeserializer(item: any): FieldMapping;
/** Managed Azure AI Search Index Definition */
export interface ManagedAzureAISearchIndex extends Index {
    /** Type of index */
    type: "ManagedAzureSearch";
    /** Vector store id of managed index */
    vectorStoreId: string;
}
export declare function managedAzureAISearchIndexSerializer(item: ManagedAzureAISearchIndex): any;
export declare function managedAzureAISearchIndexDeserializer(item: any): ManagedAzureAISearchIndex;
/** CosmosDB Vector Store Index Definition */
export interface CosmosDBIndex extends Index {
    /** Type of index */
    type: "CosmosDBNoSqlVectorStore";
    /** Name of connection to CosmosDB */
    connectionName: string;
    /** Name of the CosmosDB Database */
    databaseName: string;
    /** Name of CosmosDB Container */
    containerName: string;
    /** Embedding model configuration */
    embeddingConfiguration: EmbeddingConfiguration;
    /** Field mapping configuration */
    fieldMapping: FieldMapping;
}
export declare function cosmosDBIndexSerializer(item: CosmosDBIndex): any;
export declare function cosmosDBIndexDeserializer(item: any): CosmosDBIndex;
/** Embedding configuration class */
export interface EmbeddingConfiguration {
    /** Deployment name of embedding model. It can point to a model deployment either in the parent AIServices or a connection. */
    modelDeploymentName: string;
    /** Embedding field */
    embeddingField: string;
}
export declare function embeddingConfigurationSerializer(item: EmbeddingConfiguration): any;
export declare function embeddingConfigurationDeserializer(item: any): EmbeddingConfiguration;
/** Model Deployment Definition */
export interface Deployment {
    /** The type of the deployment */
    /** The discriminator possible values: ModelDeployment */
    type: DeploymentType;
    /** Name of the deployment */
    readonly name: string;
}
export declare function deploymentDeserializer(item: any): Deployment;
/** Alias for DeploymentUnion */
export type DeploymentUnion = ModelDeployment | Deployment;
export declare function deploymentUnionDeserializer(item: any): DeploymentUnion;
/** Type of DeploymentType */
export type DeploymentType = "ModelDeployment";
/** Model Deployment Definition */
export interface ModelDeployment extends Deployment {
    /** The type of the deployment */
    type: "ModelDeployment";
    /** Publisher-specific name of the deployed model */
    readonly modelName: string;
    /** Publisher-specific version of the deployed model */
    readonly modelVersion: string;
    /** Name of the deployed model's publisher */
    readonly modelPublisher: string;
    /** Capabilities of deployed model */
    readonly capabilities: Record<string, string>;
    /** Sku of the model deployment */
    readonly sku: Sku;
    /** Name of the connection the deployment comes from */
    readonly connectionName?: string;
}
export declare function modelDeploymentDeserializer(item: any): ModelDeployment;
/** Sku information */
export interface Sku {
    /** Sku capacity */
    capacity: number;
    /** Sku family */
    family: string;
    /** Sku name */
    name: string;
    /** Sku size */
    size: string;
    /** Sku tier */
    tier: string;
}
export declare function skuDeserializer(item: any): Sku;
/** Paged collection of Deployment items */
export interface _PagedDeployment {
    /** The Deployment items on this page */
    value: DeploymentUnion[];
    /** The link to the next page of items */
    nextLink?: string;
}
export declare function _pagedDeploymentDeserializer(item: any): _PagedDeployment;
export declare function deploymentUnionArrayDeserializer(result: Array<DeploymentUnion>): any[];
/** Red team details. */
export interface RedTeam {
    /** Identifier of the red team run. */
    readonly name: string;
    /** Name of the red-team run. */
    displayName?: string;
    /** Number of simulation rounds. */
    numTurns?: number;
    /** List of attack strategies or nested lists of attack strategies. */
    attackStrategies?: AttackStrategy[];
    /** Simulation-only or Simulation + Evaluation. Default false, if true the scan outputs conversation not evaluation result. */
    simulationOnly?: boolean;
    /** List of risk categories to generate attack objectives for. */
    riskCategories?: RiskCategory[];
    /** Application scenario for the red team operation, to generate scenario specific attacks. */
    applicationScenario?: string;
    /** Red team's tags. Unlike properties, tags are fully mutable. */
    tags?: Record<string, string>;
    /** Red team's properties. Unlike tags, properties are add-only. Once added, a property cannot be removed. */
    properties?: Record<string, string>;
    /** Status of the red-team. It is set by service and is read-only. */
    readonly status?: string;
    /** Target configuration for the red-team run. */
    target: TargetConfigUnion;
}
export declare function redTeamSerializer(item: RedTeam): any;
export declare function redTeamDeserializer(item: any): RedTeam;
/** Strategies for attacks. */
export type AttackStrategy = "easy" | "moderate" | "difficult" | "ascii_art" | "ascii_smuggler" | "atbash" | "base64" | "binary" | "caesar" | "character_space" | "jailbreak" | "ansii_attack" | "character_swap" | "suffix_append" | "string_join" | "unicode_confusable" | "unicode_substitution" | "diacritic" | "flip" | "leetspeak" | "rot13" | "morse" | "url" | "baseline";
/** Risk category for the attack objective. */
export type RiskCategory = "HateUnfairness" | "Violence" | "Sexual" | "SelfHarm";
/** Abstract class for target configuration. */
export interface TargetConfig {
    /** Type of the model configuration. */
    /** The discriminator possible values: AzureOpenAIModel */
    type: string;
}
export declare function targetConfigSerializer(item: TargetConfig): any;
export declare function targetConfigDeserializer(item: any): TargetConfig;
/** Alias for TargetConfigUnion */
export type TargetConfigUnion = AzureOpenAIModelConfiguration | TargetConfig;
export declare function targetConfigUnionSerializer(item: TargetConfigUnion): any;
export declare function targetConfigUnionDeserializer(item: any): TargetConfigUnion;
/** Azure OpenAI model configuration. The API version would be selected by the service for querying the model. */
export interface AzureOpenAIModelConfiguration extends TargetConfig {
    /** Type of the model configuration. */
    readonly type: "AzureOpenAIModel";
    /** Deployment name for AOAI model. Example: gpt-4o if in AIServices or connection based `connection_name/deployment_name` (i.e. `my-aoai-connection/gpt-4o`. */
    modelDeploymentName: string;
}
export declare function azureOpenAIModelConfigurationSerializer(item: AzureOpenAIModelConfiguration): any;
export declare function azureOpenAIModelConfigurationDeserializer(item: any): AzureOpenAIModelConfiguration;
/** Paged collection of RedTeam items */
export interface _PagedRedTeam {
    /** The RedTeam items on this page */
    value: RedTeam[];
    /** The link to the next page of items */
    nextLink?: string;
}
export declare function _pagedRedTeamDeserializer(item: any): _PagedRedTeam;
export declare function redTeamArraySerializer(result: Array<RedTeam>): any[];
export declare function redTeamArrayDeserializer(result: Array<RedTeam>): any[];
/** The type of pending upload. */
export type PendingUploadType = "None" | "BlobReference";
/** Azure AI Projects API versions */
export declare enum KnownVersions {
    /** Azure AI API version 2025-05-01. */
    V20250501 = "2025-05-01",
    /** Azure AI API version 2025-05-15-preview. */
    V20250515Preview = "2025-05-15-preview"
}
//# sourceMappingURL=models.d.ts.map